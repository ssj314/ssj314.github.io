[ { "title": "생성 모델", "url": "/posts/%EC%83%9D%EC%84%B1-%EB%AA%A8%EB%8D%B8/", "categories": "Deep Learning, Generative Model", "tags": "PyTorch, GAN", "date": "2024-03-26 00:00:00 +0900", "snippet": "기존 딥러닝 모델은 데이터를 학습하여 정답을 찾는 것이었다. 그러나, 생성 모델은 데이터를 판별하는 것에 그치지 않는다. 입력 데이터의 분포를 파악하여 유사한 데이터를 생성해 낼 수 있다. 최근엔 엄청나게 많은 데이터를 학습하는 것이 추세이므로 생성 모델을 이용해 입력 데이터를 생성해 내기도 한다.생성 모델의 구조신경망처럼 분류 혹은 회귀 모델은 판별...", "content": "기존 딥러닝 모델은 데이터를 학습하여 정답을 찾는 것이었다. 그러나, 생성 모델은 데이터를 판별하는 것에 그치지 않는다. 입력 데이터의 분포를 파악하여 유사한 데이터를 생성해 낼 수 있다. 최근엔 엄청나게 많은 데이터를 학습하는 것이 추세이므로 생성 모델을 이용해 입력 데이터를 생성해 내기도 한다.생성 모델의 구조신경망처럼 분류 혹은 회귀 모델은 판별자 모델이라고 한다. 생성 모델에는 판별자뿐 아니라 기존 데이터의 특성을 추출해 새로운 조합을 만드는 생성자 모델이 있다.생성 모델의 유형기존 데이터의 특성을 추출하는 방식에 따라 명시적 방법과 암시적 방법으로 분류한다. 명시적 방법의 대표적인 예시는 변형 오토인코더(VAE)로, 확률 변수 $p(x)$를 정의한다. 반면, 암시적 방법에 해당하는 적대적 생성 모델(GAN)은 확률 변수를 직접 정의하지 않고 오로지 신경망의 학습을 통해 컴퓨터가 알아서 정한다.Figure 1. 적대적 생성 모델과 변형 오토인코더적대적 생성 모델 (GAN)생성 모델은 판별자와 생성자로 구성된다. 생성자는 새로운 데이터를 계속 생성하고 판별자는 이것과 실제 데이터를 비교하여 어느게 진짜인지 판별한다. 생성자는 판별자가 가짜 데이터를 구분하지 못 하도록 훈련하고, 판별자는 실제 데이터를 진짜로 판단하도록 훈련한다.Figure 2. GAN의 학습 과정GAN의 동작 원리판별자의 역할을 먼저 살펴보자. 판별자는 주어진 입력 이미지 $x$에 대해 진짜일 확률 $D(x)$를 반환한다. 반면 생성자는 처음에는 노이즈 $z$를 이용해 가짜 데이터 $G(z)$를 생성해 낸다.GAN의 손실함수$D(x)$는 실제 데이터를 진짜로 판단할 확률이고, $D(G(x))$는 가짜 데이터를 진짜로 판단할 확률이다. 따라서, 판별자의 입장에서는 진짜는 진짜로, 가짜는 가짜로 판별할 수록 성능이 좋은 것이다.\\(\\max_D \\; \\log D(x)+\\log (1-D(G(z)))\\)반대로, 생성자는 판별자가 자신이 만든 데이터를 진짜라고 오인할 수록 성능이 좋다.\\(\\min_D \\; \\log (1 - D(G(z)))\\)GAN 구현 (w. PyTorch)" }, { "title": "Quadratic form", "url": "/posts/Quadratic-form/", "categories": "볼록최적화입문, Chapter 3", "tags": "Convex Optimization, Linear Algebra", "date": "2024-03-22 00:00:00 +0900", "snippet": "지난 게시물에서 벡터 공간과 고유 벡터에 대해서 배웠다. 이번 포스팅에서는 Quadratic form(이차 형식)에 대해서 알아볼 것이다.Quadratic Form이란?선형 대수학에서 이차 항만 존재하는 다항식을 Quadratic Form이라 한다. $x \\in \\mathbb{R}$일 때, 함수 $f(x) = ax^2$는 대표적인 이차 형식이다.이차 ...", "content": "지난 게시물에서 벡터 공간과 고유 벡터에 대해서 배웠다. 이번 포스팅에서는 Quadratic form(이차 형식)에 대해서 알아볼 것이다.Quadratic Form이란?선형 대수학에서 이차 항만 존재하는 다항식을 Quadratic Form이라 한다. $x \\in \\mathbb{R}$일 때, 함수 $f(x) = ax^2$는 대표적인 이차 형식이다.이차 형식을 벡터 차원으로 확장할 수 있다. $x \\in \\mathbb{R}^n$인 벡터에 대해 이차 형식은 다음과 같이 정의한다.\\[f(x)=x^TAx\\]이 때, 행렬 $A$는 Symmetric이다. 왜 대칭 행렬을 쓰는 지는 뒤에서 배우겠다.예시 1벡터 $x=(x_1, x_2)$와 행렬 \\(A=\\begin{bmatrix} 4 &amp; 0 \\\\ 0 &amp; 3\\end{bmatrix}\\)를 가정해 보자. 그러면,\\[x^TAx=\\begin{bmatrix} x_1 &amp; x_2 \\end{bmatrix}\\begin{bmatrix} 4 &amp; 0 \\\\ 0 &amp; 3 \\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} =\\begin{bmatrix} x_1 &amp; x_2 \\end{bmatrix}\\begin{bmatrix} 4x_1 \\\\ 3x_2 \\end{bmatrix}\\]따라서, $f(x) = 4x_1^2+3x_2^2$이다.예시 2행렬 \\(A=I=\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 1\\end{bmatrix}\\)를 가정해 보자. 그러면, $f(x)=x^Tx= ||x||^2$이다. 따라서, Norm도 Convex Function임을 알 수 있다.대칭 행렬을 쓰는 이유이차 형식에서 대칭 행렬만 쓰는 이유는 대칭이 아닌 행렬은 결국 대칭 행렬로 바꾸어 표현할 수 있기 때문이다. 어떤 이차 형식에서 행렬 $A$가 대칭이 아니라고 가정해 보자. 이차 형식의 값은 스칼라이므로 $f(x)=f(x)^T$가 성립한다. 따라서,\\[\\begin{align}f(x) &amp;= x^TAx=f(x)^T=x^TA^Tx \\\\ \\\\f(x) &amp;= \\frac{x^TAx}{2} + \\frac{x^TAx}{2} = \\frac{x^TAx}{2} + \\frac{x^TA^Tx}{2} = x^T \\frac{(A^T + A)}{2} x \\end{align}\\]따라서, 이차 형식 $f(x)$는 \\(Q=\\frac{(A^T + A)}{2}\\)인 대칭 행렬로 바꾸어 표현할 수 있다. 그렇기에 굳이 비대칭 행렬을 쓸 필요가 없는 것이다.다양한 형태의 이차 형식이차 형식은 크게 3가지 종류로 분류할 수 있다. 한 점으로 모이는 형태 한 쪽으로 무한히 뻗어나가는 형태 위 아래로 무한히 발산하는 형태Figure 1. 다양한 형태의 이차 형식행렬의 부호에 따라 세 가지 형태로 분류되는데 다음 게시물에서 행렬의 부호를 구분하는 방법을 알아볼 것이다." }, { "title": "Convex Set (2)", "url": "/posts/Convex-Set-(2)/", "categories": "볼록최적화입문, Chapter 2", "tags": "Convex Optimization", "date": "2024-03-16 00:00:00 +0900", "snippet": "벡터의 비교일반적으로 벡터끼리는 부등호를 통해 비교할 수 없다. 그러나, 성분끼리 비교하여 모두 특정한 조건이 성립한다면 부등호를 이용할 수 있도록 할 것이다.\\(x \\leq y \\iff \\forall_{1\\leq i\\leq n} \\; (x_i \\leq y_i)\\)단, 하나의 성분이라도 조건을 만족하지 않는다면 부등호를 통해 비교할 수 없다.Posit...", "content": "벡터의 비교일반적으로 벡터끼리는 부등호를 통해 비교할 수 없다. 그러나, 성분끼리 비교하여 모두 특정한 조건이 성립한다면 부등호를 이용할 수 있도록 할 것이다.\\(x \\leq y \\iff \\forall_{1\\leq i\\leq n} \\; (x_i \\leq y_i)\\)단, 하나의 성분이라도 조건을 만족하지 않는다면 부등호를 통해 비교할 수 없다.Positive Definite Matrices벡터와 마찬가지로 행렬도 특별한 방법을 이용하여 부호를 따질 수 있다.대칭 행렬 $A \\in \\mathcal{S}^{n}$와 벡터 $x \\in \\mathbb{R}^n$가 있을 때, $x^TAx &gt; 0$를 만족한다면 이 행렬을 Positvie Definite Matrix라고 한다 (단, $x \\neq 0$). 만약, $x^TAx \\geq 0$라면 Positive Semi-Definite Matrix라고 한다.다만, 일반적인 부등호를 사용하면 혼동이 생길 수 있으므로, 어떤 행렬이 PD라면 $A \\succ 0$로 표현한다.Polyhedra다면체 (Polyhedra)는 유한한 선형 부등식과 방정식의 해집합이다.\\(\\mathcal{P}=\\{x \\; \\vert \\; Ax \\leq b, \\; Cx=d\\}\\qquadA \\in \\mathbb{R}^{m\\times n}, \\;C\\in \\mathbb{R}^{k\\times n}\\)이 때, 부등식은 반공간, 방정식은 초평면의 정의에 해당하므로, 다면체는 반공간과 초평면의 교집합으로 볼 수 있다.Seperating Hyperplane theroem두 개의 서로소인 Convex Set이 있다면, 집합을 가르는 Hyperplane이 항상 존재한다.Figure 1. Hyperplane이 두 Convex Set을 나눈다.직관적으로 생각해 봤을 때, 두 집합이 볼록하기 때문에 당연히 나눌 수 있다는 건 떠올리기 쉽다. 이제 귀류법을 통해 수학적으로 증명해 볼 것이다.우선, 두 가지 조건이 필요하다. 두 집합을 잇는 최소 길이의 선분 $\\overline{cd}$ \\선분의 중심에 수직인 Hyperplane만약, 이 평면이 두 집합을 이분하지 못 한다면, 공간 어딘가에서 집합 $D$와의 교점 $d’$이 존재할 것이다. 그러면, 선분 $\\overline{dd’}$ 위 모든 점 또한 집합 $D$에 속한다. Figure 2. Hyperplane이 집합을 이분하지 않는 경우여기서 모순이 발생한다. 세 점 $c, d, d’$가 예각삼각형을 이루므로 두 집합을 잇는 더 짧은 선분을 구할 수 있다. 1번 조건을 위반하기 때문에 가정은 성립하지 않는다.Supporting Hyperplane theorem어떤 Convex Set은 항상 경계면에서 그은 Halfspace 영역 안에 포함된다. Figure 3. Non-Convex Set에서 Supporting Hyperplane을 그린 모습이다.Convexity Preserving OperationsIn this section, We’ll describe some of the operations that preserve the convexity of sets.IntersectionsConvexity is preserved under the intersections. If an infinite number of sets $S_i$ are all convex, then $\\bigcap_{i=1}^{n} S_i$ is also convex.Affine functionsIf $S \\subseteq \\mathbb{R}^n$is convex, $a \\in \\mathbb{R}$, and $b \\in \\mathbb{R}^n$, then the set $aS + b$is convex.\\(aS + b = \\{ ax + b \\; | \\; x \\in S\\}\\)Minkowski AdditionMinkowski addition is one way to append two sets.\\(A \\oplus B \\equiv\\{ x+y \\; | \\; x \\in A, \\; y \\in B\\}\\)It also preserves the convexity of the sets.이 연산이 중요한 이유는 연산이 성립하기만 하면 따로 볼록 집합임을 증명하지 않아도 되기 때문이다. 이제는 Convex Set (Halfspace와 Hyperplane)의 교집합인 다면체 (Polyhedra)는 따로 증명하지 않아도 Convex Set임을 알 수 있다.Convex, Affine, Cone, 그리고 Subspaces앞서 정의한 집합을 보면 어느 공간이 더 큰 지 혼동하는 경우가 많다. 집합의 제약 조건이 더 많아 더 작은 공간이라고 착각하기 쉬운데, 사실은 그 반대다.Figure 4. 네 집합의 관계를 나타낸 그림이다.그림을 보면 알 수 있듯이, 볼록 집합의 공간이 가장 크다. 그 이유는 볼록 집합을 정의할 때 가장 엄격한 조건을 달아주었기 때문이다.정리이번 장에서는 최적화의 기본이 되는 볼록 집합에 대해서 알아보았다. 선형 결합에서 시작하여, 직선, 그리고 선분을 거쳐 볼록 집합을 정의하였다. 다음 장에서는 이제 본격적으로 함수에 대해서 다뤄볼 것이다." }, { "title": "Convex Set (1)", "url": "/posts/Convex-Set-(1)/", "categories": "볼록최적화입문, Chapter 2", "tags": "Convex Optimization", "date": "2024-03-16 00:00:00 +0900", "snippet": "Convex 집합은 임의의 두 점을 꺼내 선분을 그었을 때 선분 위에 존재하는 모든 점을 포함하는 집합을 말한다. Convex 집합이 중요한 이유는 볼록 최적화를 이해하는데 기본이 되는 개념이기 때문이다. 우선 기초가 되는 Affine 집합부터 알아보자.Affine Set집합 $\\mathcal{A}\\in R^n$에 속한 두 점 $x_1, \\; x_2$...", "content": "Convex 집합은 임의의 두 점을 꺼내 선분을 그었을 때 선분 위에 존재하는 모든 점을 포함하는 집합을 말한다. Convex 집합이 중요한 이유는 볼록 최적화를 이해하는데 기본이 되는 개념이기 때문이다. 우선 기초가 되는 Affine 집합부터 알아보자.Affine Set집합 $\\mathcal{A}\\in R^n$에 속한 두 점 $x_1, \\; x_2$를 꺼내 직선을 그었을 때 직선 위 모든 점이 이 집합에 속한다면 Affine 집합이다.\\[\\theta x_1 + (1-\\theta) x_2 \\in \\mathcal{A}\\]Affine CombinationAffine 결합은 계수의 합이 1인 특수한 선형 결합이다. 귀납법을 통해 Affine 집합은 항상 원소의 모든 Affine 결합을 포함한다는 결론을 얻을 수 있다.\\[\\theta_1 x_1+ \\theta_2 x_2+ \\cdots + \\theta_n x_n\\quad\\text{and}\\quad \\sum \\limits_{i=1}^n \\theta_i x_i = 1\\]예시 1모든 평면은 Affine Set에 속한다. 평면에서 임의의 두 점을 골라 직선을 만들면 직선 위 모든 점은 항상 평면에 속한다. 다만, 평면의 일부분은 Affine Set이 될 수 없다.Figure 1. 두 점을 잇는 직선이 매개변수를 통해 표현되었다.선형 방정식의 해집합도 Affine Set이다. 어떤 선형 방정식의 해집합 $S=\\{ x \\; | \\; Ax=b\\}$를 생각해 보자. $x_1, \\; x_2 \\in S$이고 $x_3=ax_1+(1-a)x_2$라 가정하자.\\[\\begin{align}Ax_3 \\quad &amp;= \\quad A\\cdot(ax_1+(1-a)\\cdot x_2) \\\\ \\quad &amp;= \\quad a\\cdot Ax_1+(1-a)\\cdot Ax_2 \\\\ \\quad &amp;= \\quad a\\cdot b+(1-a)\\cdot b \\\\ \\quad &amp;= \\quad b\\end{align}\\]따라서, 선형 방정식의 해집합도 Affine Set이다.Convex Set어떤 집합 $C \\in \\mathbb{R}^n$ 에 속한 두 점 $x_1, \\; x_2$ 를 잇는 선분을 그었을 때 선분 위 모든 점이 $C$에 다시 속하면 이 집합을 Convex Set이라 한다.\\[\\theta \\cdot x_1 + (1-\\theta) \\cdot x_2 \\in C \\qquad \\theta \\in [0, 1]\\]caption Figure 2. 첫 번째는 볼록 집합이다. 그러나, 나머지는 그렇지 않다. Convex Set을 구분하는 방법은 모든 면이 바깥으로 볼록한 지 확인하는 것이다. 두 번째 집합은 오목하게 들어간 부분에서 정의를 위반하고, 세 번째 집합은 불연속인 부분에서 정의를 위반하는 예시를 찾을 수 있다.Convex CombinationConvex Combination\\(x=\\theta_1 x_1+\\theta_2 x_2+ \\cdots + \\theta_n x_n \\quad \\text{where} \\quad \\theta_i\\in \\mathbb{R}\\)Convex Hull볼록 껍질 (Convex Hull)은 다음과 같이 정의한다.\\(\\text{conv} \\; C = \\{\\theta_1x_1+\\cdots \\theta_kx_k \\; | \\; x_i \\in C, \\; \\theta_1 + \\cdots + \\theta_k = 1\\}\\)Convex Hull은 어떤 집합의 모든 점을 볼록 조합한 것들의 집합이다.Convex Hull은 어떤 집합의 모든 점을 포함하는 Convex Set 중 가장 작은 것에 해당한다.만약, 어떤 집합 S가 Convex Set이라면 Convex Hull 은 자기 자신이 된다. Figure 3. 두 영역은 원래 볼록 집합이 아닌 것을 볼록 집합으로 만든 것이다. " }, { "title": "5. GitHub 연동하기", "url": "/posts/5.-Github-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0/", "categories": "Dev, Git", "tags": "", "date": "2024-03-10 00:00:00 +0900", "snippet": "Git은 로컬 저장소에서 버젼을 관리하는 프로그램이다. 그런데, 협업을 해야 되서 버젼 관리를 공유해야 할 땐 어떻게 해야 할까? 이 떄 사용하는 것이 GitHub같은 온라인 저장소다.원격 저장소에 올리기우리가 로컬 환경에서 열심히 개발을 해서 여러 개의 커밋을 생성하였다고 가정하자. 이제 GitHub 저장소에 올려 다른 사람들과 공유하고 싶다. 이 ...", "content": "Git은 로컬 저장소에서 버젼을 관리하는 프로그램이다. 그런데, 협업을 해야 되서 버젼 관리를 공유해야 할 땐 어떻게 해야 할까? 이 떄 사용하는 것이 GitHub같은 온라인 저장소다.원격 저장소에 올리기우리가 로컬 환경에서 열심히 개발을 해서 여러 개의 커밋을 생성하였다고 가정하자. 이제 GitHub 저장소에 올려 다른 사람들과 공유하고 싶다. 이 때, push 명령어를 이용한다.git push {repo_addr} main그런데, 매 번 주소를 입력하는 것은 매우 번거롭다. 따라서, 변수에 저장하여 다음 번부터는 더 이상 입력하지 않도록 할 수 있다. 그러면 이제 주소를 작성할 필요 없이 git push만으로 올릴 수 있다.git remote add origin {repo_addr}원격 저장소 불러오기만약, 내가 팀장이 아니라 원격 저장소에 있는 내용을 불러와야 한다면 어떻게 할까? 적당한 로컬 디렉토리에 폴더를 하나 생성한 다음 터미널에 다음 명령어를 입력해 보자.git clone {repository_path}이제 로컬 저장소에서도 똑같은 코드를 볼 수 있다. 그러나, Github에 변경사항이 올라온다고 해서 로컬 저장소도 자동으로 바뀌는 것은 아니다. 그러다 보니 Github에 있는 파일과 내 로컬 저장소에 있는 파일이 다를 수 있다. 이러면 오류가 발생한다.git pull원격 저장소와 로컬 저장소의 파일이 다르면 오류가 발생하기 때문에 매 번 프로젝트를 올리기 전에 git pull 명령어를 입력해야 한다. 그러면 원격 저장소와 내 로컬 저장소가 병합되어 더 이상 오류가 발생하지 않는다.Branch 생성하기앞선 장에서 이미 branch를 생성하는 것을 배웠다. 그러나, 원격 저장소에서도 branch를 만들 수 있다. GitHub에서 직접 생성하기 로컬 저장소에서 생성하여 올리기Github에서 직접 생성한다면 별도의 설정 없이 그대로 이용하면 된다. 그러나, 로컬 저장소에서 branch를 생성했다면 다음과 같이 명령어를 입력해야 한다.git push {repo_addr} {branch_name}Pull Request원격 저장소에서 branch를 생성했다면 이제는 합쳐야 한다. 로컬 저장소에서 작업할 때는merge 명령어로 가능했지만 협업을 하는 원격 저장소에서는 아무렇게나 병합하면 안된다. 따라서, pull request라는 기능이 있다.Pull Requst는 Github 페이지에서 요청을 생성하고, 어느 브랜치를 합칠 것인지 고르면 된다. 그러면 최종적으로 branch를 합치는 버튼이 생긴다." }, { "title": "4. 이전 버젼으로 되돌리기", "url": "/posts/4.-%EC%9D%B4%EC%A0%84-%EB%B2%84%EC%A0%BC%EC%9C%BC%EB%A1%9C-%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0/", "categories": "", "tags": "", "date": "2024-03-10 00:00:00 +0900", "snippet": "열심히 커밋만 하면 Git을 이용하는 의미가 없다. Git은 버젼을 관리해주는 프로그램이다. 따라서, 예전에 커밋한 것으로 돌아가는 행위도 가능하다.개별 파일 되돌리기파일을 수정하다가 마음에 들지 않아 수정하기 전으로 돌아가고 싶다. 내용이 많지 않다면 Ctrl+Z로 금방 복구할 수 있지만 수정한 코드가 100줄, 200줄 씩 넘어가다 보면 복잡해진다...", "content": "열심히 커밋만 하면 Git을 이용하는 의미가 없다. Git은 버젼을 관리해주는 프로그램이다. 따라서, 예전에 커밋한 것으로 돌아가는 행위도 가능하다.개별 파일 되돌리기파일을 수정하다가 마음에 들지 않아 수정하기 전으로 돌아가고 싶다. 내용이 많지 않다면 Ctrl+Z로 금방 복구할 수 있지만 수정한 코드가 100줄, 200줄 씩 넘어가다 보면 복잡해진다. 이때, restore 명령어를 이용하면 최근 commit한 파일로 되돌아간다.git restore {file_name}Commit 취소하기열심히 코드를 짜고 커밋을 여러 번 하였다. 그런데, 예전에 커밋한 내역 중 하나에서 오류가 발생하였다. 이럴 때에는 특정 커밋만 삭제할 수 있다. 해시는 git log 명령어를 통해 버젼마다 확인할 수 있으며 방향키를 통해 선택할 수도 있다.git revert {hash}revert 명령어를 통해 특정 커밋을 지우면 새로운 커밋이 추가된다. 만약 해시를 찾기 귀찮고 몇 번 전에 실시한 커밋을 지우고 싶다면 다음 명령어를 입력하면 된다.git revert head-{n}Commit 되돌리기커밋을 취소할 수도 있지만 예전 버전으로 되돌아 갈 수도 있다.git checkout {hash}git checkout head~{num}만약, 이전 버전으로 돌아갔다가 마음에 안 들면 다시 되돌아올 수도 있다. git checkout {branch_name} 명령어를 입력하면 해당 브랜치의 최신 버전으로 되돌아 간다." }, { "title": "3. Branch 만들기", "url": "/posts/3.-Branch-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "Dev, Git", "tags": "", "date": "2024-03-10 00:00:00 +0900", "snippet": "코드를 수정하다가 보면 실수해서 원본 파일을 변형할 수 있다. 이런 실수를 방지하기 위해 우리는 일종의 복사본을 만들어서 수정하고 나중에 합칠 수 있다. 프로젝트의 복사본을 Git에서는 Branch라고 부른다.Branch 생성하기Git에서 Branch를 생성하는 것은 매우 간단하다. 다음 명령어를 터미널에 작성하면 알아서 Branch가 새로 생겨날 것...", "content": "코드를 수정하다가 보면 실수해서 원본 파일을 변형할 수 있다. 이런 실수를 방지하기 위해 우리는 일종의 복사본을 만들어서 수정하고 나중에 합칠 수 있다. 프로젝트의 복사본을 Git에서는 Branch라고 부른다.Branch 생성하기Git에서 Branch를 생성하는 것은 매우 간단하다. 다음 명령어를 터미널에 작성하면 알아서 Branch가 새로 생겨날 것이다.git branch {name}새로 생성한 Branch로 이동하고 싶다면 다음 명령어를 입력해 보자. 우리가 최초로 프로젝트를 생성하면 main 혹은 master라는 이름으로 Branch가 생성된다.git switch {name}복사본에서 작업을 하기 때문에 아무리 커밋을 해도 원본은 변하지 않는다. Figure 1. Branch의 원리 Branch 합치기복사본에서 작성한 코드가 완성되었다면 원본에다가 추가해 주어야 한다. 이때, merge 명령어를 통해 두 Branch를 합칠 수 있다.git switch main // or mastergit merge {branch_name} Figure 2. 두 Branch를 합친 모습이다. 그러나, 두 Branch에서 같은 부분을 수정했다면 충돌이 발생할 수 있다. VS Code와 같은 에디터를 사용한다면 손쉽게 해결할 수 있다. 에디터에서 원하는 코드만 남기고 다시 커밋하면 충돌은 말끔하게 해결된다.Branch 활용하기협업 시 여러 명의 개발자와 같은 Branch를 이용한다면 어디선가 충돌이 일어나기 쉽다. 따라서, 개별 branch를 생성하여 작업한 다음 main/master branch에 병합을 한다면 안정적으로 개발할 수 있을 것이다.Branch 삭제하기개발하면서 branch를 여러 개 생성했다가 작업이 끝나고 병합하면 더 이상 쓸 일이 없을 수도 있다. Git은 자동으로 branch를 제거해 주지 않는다. 따라서, 아래 명령어를 입력하여 수동으로 branch를 제거해 주어야 한다.git branch -d {branch_name}만약 개발 과정에서 엎어져서 병합하지 않고 삭제해야 하는 경우에는 조금 다른 명령어를 입력해야 한다.git branch -D {branch_name}" }, { "title": "2. Workflow 이해하기", "url": "/posts/2.-Workflow-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/", "categories": "Dev, Git", "tags": "", "date": "2024-03-10 00:00:00 +0900", "snippet": "Git을 제대로 사용하려면 내부에서 어떻게 파일들이 처리되는지 알아야 한다. Git은 로컬 저장소를 크게 3 단계로 구분한다.Working Directory현재 내가 작업 중인 공간에 해당한다. Working Directory에선 파일을 추가, 편집 혹은 삭제할 수 있다.Working Directory의 구분Working Directory는 크게 un...", "content": "Git을 제대로 사용하려면 내부에서 어떻게 파일들이 처리되는지 알아야 한다. Git은 로컬 저장소를 크게 3 단계로 구분한다.Working Directory현재 내가 작업 중인 공간에 해당한다. Working Directory에선 파일을 추가, 편집 혹은 삭제할 수 있다.Working Directory의 구분Working Directory는 크게 untracked와 tracked 영역으로 구분하고 tracked 영역은 다시 unmodified와 modified 영역으로 나뉜다.untracked 영역은 새로 생성한 파일처럼 Git이 아직 정보를 갖고 있지 않는 파일들로 구성된다. 반면, tracked 영역은 이미 Git이 정보를 갖고 있어 상태를 확인할 수 있는 파일들로 구성된다.따라서, 파일을 Staging Area로 이동시키려면 반드시 tracked면서 modified 영역에 속해야 한다. git add {file_name} 명령을 수행하면 파일을 Staging Area로 옮길 수 있다.Staging Area완성된 파일을 커밋하기 전에 보관하는 공간이다. Working Directory에 있는 파일을 git add {file_name} 명령어를 통해 Staging Area로 이동시킬 수 있다.Git Directory프로젝트를 버젼별로 보관하는 공간이다. git commit 명령어를 통해 스냅샷을 남기면 Staging Area에 있던 파일들이 이 공간으로 이동된다. 해시를 통해 버전, 메시지와 작성자 정보 등 다양한 데이터가 함께 저장된다.git checkout 명령어를 통해 Git Directory에 있던 파일들을 다시 Working Directory로 이동시킬 수도 있다.Git? GitHub?Git은 내 컴퓨터에서 작동하는 버전 관리 프로그램이다. 반면, GitHub는 원격 저장소에 해당한다. 다만, 로컬 저장소에 있는 파일들을 안전하게 보관하기 위해 원격 저장소를 이용한다.로컬 저장소에서 git push 명령어를 입력하면 Git directory를 원격 저장소에 올릴 수 있다. 반대로, git clone 또는 git pull 명령어를 통해 원격 저장소를 다운 받을 수 있다.본격적으로 Git 이용해 보기파일을 생성하거나 수정하는 등 상태에 변화가 생기면 git status 명령어를 통해 확인할 수 있다. 파일이 어느 영역에 속해 있는 지도 확인할 수 있다.만약, Staging Area로 이동한 파일을 다시 수정하고 싶다면 git rm --cached {file_name} 명령을 입력하면 된다.모든 변경 사항을 반영하려면 git add . 또는 git add -A 명령어를 이용한다..gitignore폴더 내에 있는 어떤 파일들은 추가하고 싶지 않을 수 있다. 예를 들어 모듈을 다운 받은 파일의 경우 굳이 버전에 기록할 필요는 없다. 이 때, gitignore 파일을 이용한다.다음 명령어를 터미널에 입력하면 파일이 알아서 .gitignore 파일에 등록되고 Git이 더 이상 추적하지 않는다.echo {file_name} &gt;&gt; .gitignoregit diffgit status 명령어로는 어떤 파일이 어떻게 변했는지 알 수 없다. 변경 내역을 알고 싶다면 git diff 명령어를 이용해야 한다. 예를 들어, a.txt 파일을 Staging Area로 이동시킨 다음에 수정한다면 터미널에 다음과 같이 표시된다.diff --git a/a.txt b/a.txt...{original}\\+ {changed}\\- {changed}이 때, a/a.txt가 Staging Area에 있는 파일 또는 이전에 커밋된 버전의 파일이고, b/a.txt가 방금 변경된 파일에 해당한다.커밋 하기모든 작업이 완료되었다면 이제 하나의 버전으로 기록하여 보관할 것이다. Git은 git commit 명령을 통해 스냅샷을 찍는다. 그러면 Staging Area에 있는 파일들이 모두 Git Directory로 이동한다.다양한 명령어커밋할 때 다음과 같이 입력하면 불필요한 과정을 건너뛸 수 있다. git commit -m \"messages\"커밋 내역을 확인하는 방법git loggit add를 거치지 않고 바로 커밋하고 싶을 때git commit -am \"message\"Tip작업물을 버전 별로 관리하는 것이 의미가 있기 때문에 한 번에 모든 파일을 커밋하는 것은 의미가 없다. 따라서, 프로젝트를 세분화해서 기능 별로 커밋해서 관리하는 것이 유용하다. 그리고, 커밋할 때 남기는 메시지는 주로 동사로 하며, 오류를 고쳤다면 해당 오류에 대한 내용만 커밋해야 깔끔하게 관리할 수 있다." }, { "title": "1. 초기 설정하기", "url": "/posts/1.-%EC%B4%88%EA%B8%B0-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Dev, Git", "tags": "", "date": "2024-03-10 00:00:00 +0900", "snippet": "코드를 작성하고 마음에 안 들면 이전으로 돌아가고 싶을 때가 종종 있다. 코드가 짧거나 소규모 프로젝트면 수동으로 바꿀 수 있지만 규모가 커진다면 쉽지 않을 것이다. 이런 문제를 해결해 주는 것이 바로 Git이다.Git 초기화내 폴더에서 Git을 사용하고 싶다면 터미널에서 git init 을 입력하면 된다. 명령어를 입력하면 .git 폴더가 생성되고 ...", "content": "코드를 작성하고 마음에 안 들면 이전으로 돌아가고 싶을 때가 종종 있다. 코드가 짧거나 소규모 프로젝트면 수동으로 바꿀 수 있지만 규모가 커진다면 쉽지 않을 것이다. 이런 문제를 해결해 주는 것이 바로 Git이다.Git 초기화내 폴더에서 Git을 사용하고 싶다면 터미널에서 git init 을 입력하면 된다. 명령어를 입력하면 .git 폴더가 생성되고 Git이 디렉토리를 추적하게 된다.혹시라도 나중에 더 이상 Git을 사용하고 싶지 않다면 .git 폴더를 삭제해 주면 된다.Git 환경 설정Git의 모든 설정은 config 파일에 저장된다. Git을 편리하게 이용하려면 몇 가지 기본 설정을 해 주어야 한다.에디터 변경터미널에서 Git 명령어를 수행하면 config 파일도 터미널에서 열린다. 이는 불편하므로 우리가 주로 사용하는 VS Code로 변경할 것이다. 먼저, 터미널에서 code 명령어가 활성화되어 있어야 한다.code 명령어가 활성화되어 있다면 아래 명령어를 터미널에 입력해 주자.git config --global core.editor \"code\"에디터가 열려 있는 중에 Git 작업을 중단하고 싶다면 \"code\"대신 \"code --wait\"을 입력해 준다. 이제 config 파일을 열어보자. git config --global -e를 입력하면 VS Code로 파일이 열릴 것이다.사용자 정보 설정하기나중에 다루겠지만, 커밋을 하면 파일의 버전, 사용자 정보 등 여러 정보가 암호화되어 저장된다. 따라서, 사용자 정보를 미리 등록해 줄 것이다.git config --global user.name \"ssj\"git config --global user.email \"ssangjun706@naver.com\"제대로 입력되었는지 확인하고 싶다면 다음 명령어를 입력하면 된다.git config {param}git config user.name // output: ssj운영체제마다 줄바꿈을 처리하는 방식이 다르기 때문에 나중에 협업을 위해서라도 아래 코드를 config 파일에 추가해 준다.git config --global core.autocrlf input # macOSgit config --global core.autocrlf true # Windows" } ]